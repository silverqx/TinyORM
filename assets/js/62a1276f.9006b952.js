"use strict";(self.webpackChunktinyorm_org=self.webpackChunktinyorm_org||[]).push([[57],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>y});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,y=u["".concat(l,".").concat(c)]||u[c]||d[c]||r;return n?a.createElement(y,o(o({ref:t},m),{},{components:n})):a.createElement(y,o({ref:t},m))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9823:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:3,sidebar_label:"Casts",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},o="TinyORM: Casting",s={unversionedId:"tinyorm/casts",id:"tinyorm/casts",title:"TinyORM: Casting",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",source:"@site/docs/tinyorm/casts.mdx",sourceDirName:"tinyorm",slug:"/tinyorm/casts",permalink:"/tinyorm/casts",draft:!1,editUrl:"https://github.com/silverqx/TinyORM-github.io/edit/main/docs/tinyorm/casts.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Casts",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},sidebar:"tinyormSidebar",previous:{title:"Collections",permalink:"/tinyorm/collections"},next:{title:"Serialization",permalink:"/tinyorm/serialization"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Accessors",id:"accessors",level:2},{value:"Defining An Accessor",id:"defining-an-accessor",level:3},{value:"Building Value From Multiple Attributes",id:"building-value-from-multiple-attributes",level:4},{value:"Accessor Caching",id:"accessor-caching",level:4},{value:"Attribute Casting",id:"attribute-casting",level:2},{value:"Date Casting",id:"date-casting",level:3},{value:"Date Casting, Serialization &amp; Timezones",id:"date-casting-serialization-and-timezones",level:4},{value:"Query Time Casting",id:"query-time-casting",level:3}],m={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tinyorm-casting"},"TinyORM: Casting"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#accessors"},"Accessors"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#defining-an-accessor"},"Defining An Accessor")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#attribute-casting"},"Attribute Casting"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#date-casting"},"Date Casting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#query-time-casting"},"Query Time Casting"))))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," string that is stored in your database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance when it is accessed via your TinyORM model. Or, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"tinyint")," number that is stored in the database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," when you access it on the TinyORM model."),(0,i.kt)("h2",{id:"accessors"},"Accessors"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Accessors are currently only used during the serialization by the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization#appending-values-to-json"},"Appending Values")," feature. They are not used during the ",(0,i.kt)("inlineCode",{parentName:"p"},"getAttribute")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"getAttributeValue")," methods calls.")),(0,i.kt)("h3",{id:"defining-an-accessor"},"Defining An Accessor"),(0,i.kt)("p",null,"An accessor transforms a TinyORM attribute value when it is accessed (currently during serialization only by the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization#appending-values-to-json"},"Appending Values"),' feature). To define an accessor, create a protected method on your model to represent the accessible attribute. This method name should correspond to the "camelCase" representation of the true underlying model attribute / database column when applicable.'),(0,i.kt)("p",null,"In this example, we'll define an accessor for the ",(0,i.kt)("inlineCode",{parentName:"p"},"first_name")," attribute. The accessor will automatically be called by TinyORM during serialization if the ",(0,i.kt)("inlineCode",{parentName:"p"},"first_name")," attribute is defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_appends")," data member set. All attribute accessor methods must return the ",(0,i.kt)("inlineCode",{parentName:"p"},"Orm::Tiny::Casts::Attribute"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include <orm/tiny/model.hpp>\n\nusing Orm::Tiny::Casts::Attribute;\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User>\n{\n    friend Model;\n    using Model::Model;\n\nprotected:\n    /*! Get the user\'s first name (accessor). */\n    Attribute firstName() const noexcept\n    {\n        return Attribute::make(/* get */ [this]() -> QVariant\n        {\n            auto firstName = getAttribute<QString>("first_name");\n\n            if (!firstName.isEmpty())\n                firstName[0] = firstName.at(0).toUpper();\n\n            return firstName;\n        });\n    }\n\nprivate:\n    /*! Map of mutator names to methods. */\n    inline static const QHash<QString, MutatorFunction> u_mutators {\n        {"first_name", &User::firstName},\n    };\n};\n')),(0,i.kt)("p",null,"All accessor methods return an ",(0,i.kt)("inlineCode",{parentName:"p"},"Attribute")," instance which defines how the attribute will be accessed. To do so, we supply the ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Attribute")," class constructor or ",(0,i.kt)("inlineCode",{parentName:"p"},"Attribute::make")," factory method."),(0,i.kt)("p",null,"As you can see, the current model is captured by-reference using the ",(0,i.kt)("inlineCode",{parentName:"p"},"[this]")," capture, allowing you to obtain a value by the ",(0,i.kt)("inlineCode",{parentName:"p"},"getAttribute")," method inside the lambda expression, manipulate it and return a new value."),(0,i.kt)("p",null,"You can also use the second overload that allows you to pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"ModelAttributes")," unordered map to the lambda expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Tiny::Casts::Attribute;\nusing Orm::Tiny::Types::ModelAttributes;\n\nprotected:\n    /*! Get the user\'s first name (accessor). */\n    Attribute firstName() const noexcept\n    {\n        return Attribute::make(\n               /* get */ [](const ModelAttributes &attributes) -> QVariant\n        {\n            auto firstName = attributes.at<QString>("first_name");\n\n            if (!firstName.isEmpty())\n                firstName[0] = firstName.at(0).toUpper();\n\n            return firstName;\n        });\n    }\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/silverqx/TinyORM/blob/main/include/orm/tiny/types/modelattributes.hpp"},(0,i.kt)("inlineCode",{parentName:"a"},"ModelAttributes"))," container extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unordered_map<QString, QVariant>")," and adds the ",(0,i.kt)("inlineCode",{parentName:"p"},"at<T>")," method that allows you to cast the underlying QVariant value."),(0,i.kt)("p",null,"Special note should be given to the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_mutators")," static data member map, which maps accessors' attribute names to its methods. This data member is ",(0,i.kt)("strong",{parentName:"p"},"required")," because C++ does not currently support reflection."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you would like these computed values to be added to the vector, map, or JSON representations of your model, ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization#appending-values-to-json"},"you will need to append them"),".")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"You must guarantee that the current model will live long enough to avoid the dangling reference and crash if the current model is captured by-reference. Of course, you can capture it by-copy in edge cases or if you can't guarantee this.")),(0,i.kt)("h4",{id:"building-value-from-multiple-attributes"},"Building Value From Multiple Attributes"),(0,i.kt)("p",null,"Sometimes your accessor may need to transform multiple model attributes into a single value. You can use both methods described above to accomplish this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Constants::SPACE_IN;\nusing Orm::Tiny::Casts::Attribute;\n\nprotected:\n    /*! Get the user\'s full name (accessor). */\n    Attribute fullName() const noexcept\n    {\n        return Attribute::make(/* get */ [this]() -> QVariant\n        {\n            return SPACE_IN.arg(getAttribute<QString>("first_name"),\n                                getAttribute<QString>("last_name"));\n        });\n    }\n')),(0,i.kt)("p",null,"Or you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ModelAttributes")," overload:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'/*! Get the user\'s full name (accessor). */\nAttribute fullName() const noexcept\n{\n    return Attribute::make(\n            /* get */ [](const ModelAttributes &attributes) -> QVariant\n    {\n        return SPACE_IN.arg(attributes.at<QString>("first_name"),\n                            attributes.at<QString>("last_name"));\n    });\n}\n')),(0,i.kt)("h4",{id:"accessor-caching"},"Accessor Caching"),(0,i.kt)("p",null,"Sometimes computing an attribute value can be intensive, in this case, you can enable caching for this attribute value. To accomplish this, you have to invoke the ",(0,i.kt)("inlineCode",{parentName:"p"},"shouldCache")," method when defining your accessor:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Constants::SPACE_IN;\nusing Orm::Tiny::Casts::Attribute;\n\nprotected:\n    /*! Get the user\'s full name (accessor). */\n    Attribute fullName() const noexcept\n    {\n        return Attribute::make(/* get */ [this]() -> QVariant\n        {\n            return SPACE_IN.arg(getAttribute<QString>("first_name"),\n                                getAttribute<QString>("last_name"));\n        }).shouldCache();\n    }\n')),(0,i.kt)("h2",{id:"attribute-casting"},"Attribute Casting"),(0,i.kt)("p",null,"Attribute casting provides functionality that allows converting model attributes to the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"metatype")," when it is accessed via your TinyORM model. The core of this functionality is a model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member that provides a convenient method of converting attributes' ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"internal types")," to the defined cast types."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member should be the ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unordered_map<QString, Orm::CastItem>")," where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are:"),(0,i.kt)("div",{id:"casts-types-list"},(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QString")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Boolean")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Bool")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Integer")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Int")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInteger")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::LongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::ULongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Short")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UShort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDate")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDateTime")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Real")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Float")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("code",null,"CastType::Decimal:<precision>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QByteArray")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The primary key name defined by the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_primaryKey")," model's data member is automatically cast to the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::ULongLong")," for all database drivers if the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_incrementing")," is set to true (its default value).")),(0,i.kt)("p",null,"To demonstrate attribute casting, let's cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute, which is stored in our database as an integer (",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#pragma once\n\n#include <orm/tiny/model.hpp>\n\nusing Orm::Tiny::CastItem;\nusing Orm::Tiny::CastType;\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User>\n{\n    friend Model;\n    using Model::Model;\n\n    /*! The attributes that should be cast. */\n    inline static std::unordered_map<QString, CastItem> u_casts {\n        {"is_admin", CastType::Boolean},\n    };\n};\n')),(0,i.kt)("p",null,"After defining the cast, the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute will always be cast to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," when you access it, even if the underlying value is stored in the database as an integer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Utils::Helpers;\n\nauto isAdmin = User::find(1)->getAttribute("is_admin");\n\n// Proof of the QVariant type\nQ_ASSERT(Helpers::qVariantTypeId(isAdmin) == QMetaType::Bool);\n\nif (isAdmin.value<bool>()) {\n    //\n}\n')),(0,i.kt)("p",null,"If you need to add a new, ",(0,i.kt)("strong",{parentName:"p"},"temporary")," cast at runtime, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"mergeCasts")," method. These cast definitions will be added to any of the casts already defined on the model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'user->mergeCasts({\n    {"is_paid", CastType::Boolean},\n    {"income", {CastType::Decimal, 2}},\n});\n')),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"You should never define a cast (or an attribute) that has the same name as a relationship.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Attributes that are ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," ",(0,i.kt)("strong",{parentName:"p"},"will also be")," cast so that the ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant"),"'s internal type will have the correct type.")),(0,i.kt)("h3",{id:"date-casting"},"Date Casting"),(0,i.kt)("p",null,"By default, TinyORM will cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"created_at")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," columns to instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),". You may cast additional date attributes by defining additional date casts within your model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member unordered map. Typically, dates should be cast using the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::Timestamp")," cast types."),(0,i.kt)("p",null,"When a database column is of the date type, you may set the corresponding model attribute value to a UNIX timestamp, date string (",(0,i.kt)("inlineCode",{parentName:"p"},"Y-m-d"),"), date-time string, ",(0,i.kt)("inlineCode",{parentName:"p"},"QDate"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance. The date's value will be correctly converted and stored in your database.",(0,i.kt)("br",null),"\nThe same is true for the datetime or timestamp database column types, you can set the corresponding model attribute value to a UNIX timestamp, date-time string, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance."),(0,i.kt)("p",null,"When defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast, you may also specify the date's format. In this case you must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types. This format will be used when the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization"},"model is serialized to a vector, map, or JSON"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'/*! The attributes that should be cast. */\ninline static std::unordered_map<QString, CastItem> u_casts {\n    {"created_at", {CastType::CustomQDateTime, "yyyy-MM-dd"}},\n};\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types behave exactly like the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast types with the additional ",(0,i.kt)("strong",{parentName:"p"},"date's format")," functionality during ",(0,i.kt)("strong",{parentName:"p"},"serialization"),".")),(0,i.kt)("p",null,"You may customize the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization#customizing-the-default-date-format"},"default serialization format")," for all of your model's dates or datetimes by defining a ",(0,i.kt)("inlineCode",{parentName:"p"},"serializeDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"serializeDateTime")," methods on your model. These methods do not affect how your dates are formatted for storage in the database:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'/*! Prepare a date for vector, map, or JSON serialization. */\nQString serializeDate(const QDate date)\n{\n    return date.toString("yyyy-MM-dd");\n}\n\n/*! Prepare a datetime for vector, map, or JSON serialization. */\nQString serializeDateTime(const QDateTime &datetime)\n{\n    return datetime.toUTC().toString("yyyy-MM-ddTHH:mm:ssZ");\n}\n')),(0,i.kt)("p",null,"To specify the format that should be used when actually storing a model's dates within your database, you should define a ",(0,i.kt)("inlineCode",{parentName:"p"},"u_dateFormat")," data member on your model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/*! The storage format of the model's date columns. */\ninline static QString u_dateFormat {QLatin1Char('U')};\n")),(0,i.kt)("p",null,"This format can be any format that the QDateTime's ",(0,i.kt)("inlineCode",{parentName:"p"},"fromString")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," methods accept or the special ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format that represents the UNIX timestamp (this ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format is TinyORM-specific and isn't supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),")."),(0,i.kt)("h4",{id:"date-casting-serialization-and-timezones"},"Date Casting, Serialization & Timezones"),(0,i.kt)("p",null,"By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," casts will serialize dates to a UTC ISO-8601 date string (",(0,i.kt)("inlineCode",{parentName:"p"},"yyyy-MM-ddTHH:mm:ss.zzzZ"),"), regardless of the timezone specified in your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option. You are strongly encouraged to always use this serialization format, as well as to store your application's dates in the UTC timezone by not changing your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option from its default ",(0,i.kt)("inlineCode",{parentName:"p"},"Qt::UTC")," value. Consistently using the UTC timezone throughout your application will provide the maximum level of interoperability with other date manipulation libraries or services written in any programming language."),(0,i.kt)("p",null,"If a custom format is applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},'{CastType::CustomQDateTime, "yyyy-MM-dd HH:mm:ss"}'),", the inner timezone of the QDateTime instance will be used during date serialization. Typically, this will be the timezone specified in your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option."),(0,i.kt)("h3",{id:"query-time-casting"},"Query Time Casting"),(0,i.kt)("p",null,"Sometimes you may need to apply casts while executing a query, such as when selecting a raw value from a table. For example, consider the following query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Models::Post;\nusing Models::User;\n\nauto users = User::select("users.*")\n             ->addSelect(\n                 Post::selectRaw("MAX(created_at)")\n                     ->whereColumnEq("user_id", "users.id")\n                     .toBase(),\n                 "last_posted_at"\n             ).get();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"last_posted_at")," attribute on the results of this query will be a simple string. It would be wonderful if we could apply a ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast to this attribute when executing the query. Thankfully, we may accomplish this using the ",(0,i.kt)("inlineCode",{parentName:"p"},"withCasts")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"withCast")," methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'auto users = User::select("users.*")\n             ->addSelect(Post::selectRaw("MAX(created_at)")\n                             ->whereColumnEq("user_id", "users.id")\n                             .toBase(),\n                         "last_posted_at")\n             .withCast({"last_posted_at", CastType::QDateTime})\n             .get();\n')))}d.isMDXComponent=!0}}]);