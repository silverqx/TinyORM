"use strict";(self.webpackChunktinyorm_org=self.webpackChunktinyorm_org||[]).push([[57],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>y});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(a),c=i,y=d["".concat(l,".").concat(c)]||d[c]||u[c]||r;return a?n.createElement(y,o(o({ref:t},m),{},{components:a})):n.createElement(y,o({ref:t},m))}));function y(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},9823:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_position:3,sidebar_label:"Casts",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},o="TinyORM: Casting",s={unversionedId:"tinyorm/casts",id:"tinyorm/casts",title:"TinyORM: Casting",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",source:"@site/docs/tinyorm/casts.mdx",sourceDirName:"tinyorm",slug:"/tinyorm/casts",permalink:"/tinyorm/casts",draft:!1,editUrl:"https://github.com/silverqx/TinyORM-github.io/edit/main/docs/tinyorm/casts.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Casts",description:"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a `datetime` string that is stored in your database to the `QDateTime` instance when it is accessed via your TinyORM model.",keywords:["c++ orm","orm","casts","casting","attributes","tinyorm"]},sidebar:"tinyormSidebar",previous:{title:"Collections",permalink:"/tinyorm/collections"},next:{title:"Serialization",permalink:"/tinyorm/serialization"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Attribute Casting",id:"attribute-casting",level:2},{value:"Date Casting",id:"date-casting",level:3},{value:"Date Casting, Serialization, &amp; Timezones",id:"date-casting-and-timezones",level:4},{value:"Query Time Casting",id:"query-time-casting",level:3}],m={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tinyorm-casting"},"TinyORM: Casting"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#introduction"},"Introduction")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#attribute-casting"},"Attribute Casting"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#date-casting"},"Date Casting")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#query-time-casting"},"Query Time Casting"))))),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Attribute casting allows you to transform TinyORM attribute values when you retrieve them on model instances. For example, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," string that is stored in your database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance when it is accessed via your TinyORM model. Or, you may want to convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"tinyint")," number that is stored in the database to the ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," when you access it on the TinyORM model."),(0,i.kt)("h2",{id:"attribute-casting"},"Attribute Casting"),(0,i.kt)("p",null,"Attribute casting provides functionality that allows converting model attributes to the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"metatype")," when it is accessed via your TinyORM model. The core of this functionality is a model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member that provides a convenient method of converting attributes' ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant")," ",(0,i.kt)("strong",{parentName:"p"},"internal types")," to the defined cast types."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member should be the ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unordered_map<QString, Orm::CastItem>")," where the key is the name of the attribute being cast and the value is the type you wish to cast the column to. The supported cast types are:"),(0,i.kt)("div",{id:"casts-types-list"},(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QString")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Boolean")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Bool")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Integer")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Int")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInteger")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UInt")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::LongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::ULongLong")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Short")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::UShort")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDate")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QDateTime")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Real")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Float")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::Double")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("code",null,"CastType::Decimal:<precision>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CastType::QByteArray")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The primary key name defined by the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_primaryKey")," model's data member is automatically cast to the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::ULongLong")," for all database drivers if the ",(0,i.kt)("inlineCode",{parentName:"p"},"u_incrementing")," is set to true (its default value).")),(0,i.kt)("p",null,"To demonstrate attribute casting, let's cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute, which is stored in our database as an integer (",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#pragma once\n\n#include <orm/tiny/model.hpp>\n\nusing Orm::Tiny::CastItem;\nusing Orm::Tiny::CastType;\nusing Orm::Tiny::Model;\n\nclass User final : public Model<User>\n{\n    friend Model;\n    using Model::Model;\n\n    /*! The attributes that should be cast. */\n    inline static std::unordered_map<QString, CastItem> u_casts {\n        {"is_admin", CastType::Boolean},\n    };\n};\n')),(0,i.kt)("p",null,"After defining the cast, the ",(0,i.kt)("inlineCode",{parentName:"p"},"is_admin")," attribute will always be cast to a ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant(bool)")," when you access it, even if the underlying value is stored in the database as an integer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Orm::Utils::Helpers;\n\nauto isAdmin = User::find(1)->getAttribute("is_admin");\n\n// Proof of the QVariant type\nQ_ASSERT(Helpers::qVariantTypeId(isAdmin) == QMetaType::Bool);\n\nif (isAdmin.value<bool>()) {\n    //\n}\n')),(0,i.kt)("p",null,"If you need to add a new, ",(0,i.kt)("strong",{parentName:"p"},"temporary")," cast at runtime, you may use the ",(0,i.kt)("inlineCode",{parentName:"p"},"mergeCasts")," method. These cast definitions will be added to any of the casts already defined on the model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'user->mergeCasts({\n    {"is_paid", CastType::Boolean},\n    {"income", {CastType::Decimal, 2}},\n});\n')),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"You should never define a cast (or an attribute) that has the same name as a relationship.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Attributes that are ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," ",(0,i.kt)("strong",{parentName:"p"},"will also be")," cast so that the ",(0,i.kt)("inlineCode",{parentName:"p"},"QVariant"),"'s internal type will have the correct type.")),(0,i.kt)("h3",{id:"date-casting"},"Date Casting"),(0,i.kt)("p",null,"By default, TinyORM will cast the ",(0,i.kt)("inlineCode",{parentName:"p"},"created_at")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," columns to instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),". You may cast additional date attributes by defining additional date casts within your model's ",(0,i.kt)("inlineCode",{parentName:"p"},"u_casts")," static data member unordered map. Typically, dates should be cast using the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::Timestamp")," cast types."),(0,i.kt)("p",null,"When a database column is of the date type, you may set the corresponding model attribute value to a UNIX timestamp, date string (",(0,i.kt)("inlineCode",{parentName:"p"},"Y-m-d"),"), date-time string, ",(0,i.kt)("inlineCode",{parentName:"p"},"QDate"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance. The date's value will be correctly converted and stored in your database.",(0,i.kt)("br",null),"\nThe same is true for the datetime or timestamp database column types, you can set the corresponding model attribute value to a UNIX timestamp, date-time string, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime")," instance."),(0,i.kt)("p",null,"When defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast, you may also specify the date's format. In this case you must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types. This format will be used when the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization"},"model is serialized to a vector, map, or JSON"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'/*! The attributes that should be cast. */\ninline static std::unordered_map<QString, CastItem> u_casts {\n    {"created_at", {CastType::CustomQDateTime, "yyyy-MM-dd"}},\n};\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types behave exactly like the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast types with the additional ",(0,i.kt)("strong",{parentName:"p"},"date's format")," functionality during ",(0,i.kt)("strong",{parentName:"p"},"serialization"),".")),(0,i.kt)("p",null,"You may customize the ",(0,i.kt)("a",{parentName:"p",href:"/tinyorm/serialization#customizing-the-default-date-format"},"default serialization format")," for all of your model's dates or datetimes by defining a ",(0,i.kt)("inlineCode",{parentName:"p"},"serializeDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"serializeDateTime")," methods on your model. These methods do not affect how your dates are formatted for storage in the database:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'/*! Prepare a date for vector, map, or JSON serialization. */\nQString serializeDate(const QDate date)\n{\n    return date.toString("yyyy-MM-dd");\n}\n\n/*! Prepare a datetime for vector, map, or JSON serialization. */\nQString serializeDateTime(const QDateTime &datetime)\n{\n    return datetime.toUTC().toString("yyyy-MM-ddTHH:mm:ssZ");\n}\n')),(0,i.kt)("p",null,"To specify the format that should be used when actually storing a model's dates within your database, you should define a ",(0,i.kt)("inlineCode",{parentName:"p"},"u_dateFormat")," data member on your model:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/*! The storage format of the model's date columns. */\ninline static QString u_dateFormat {QLatin1Char('U')};\n")),(0,i.kt)("p",null,"This format can be any format that the QDateTime's ",(0,i.kt)("inlineCode",{parentName:"p"},"fromString")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," methods accept or the special ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format that represents the UNIX timestamp (this ",(0,i.kt)("inlineCode",{parentName:"p"},"U")," format is TinyORM-specific and isn't supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"QDateTime"),")."),(0,i.kt)("h4",{id:"date-casting-and-timezones"},"Date Casting, Serialization, & Timezones"),(0,i.kt)("p",null,"By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," casts will serialize dates to a UTC ISO-8601 date string (",(0,i.kt)("inlineCode",{parentName:"p"},"yyyy-MM-ddTHH:mm:ss.zzzZ"),"), regardless of the timezone specified in your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option. You are strongly encouraged to always use this serialization format, as well as to store your application's dates in the UTC timezone by not changing your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option from its default ",(0,i.kt)("inlineCode",{parentName:"p"},"Qt::UTC")," value. Consistently using the UTC timezone throughout your application will provide the maximum level of interoperability with other date manipulation libraries or services written in any programming language."),(0,i.kt)("p",null,"If a custom format is applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDate")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::CustomQDateTime")," cast types, such as ",(0,i.kt)("inlineCode",{parentName:"p"},'{CastType::CustomQDateTime, "yyyy-MM-dd HH:mm:ss"}'),", the inner timezone of the QDateTime instance will be used during date serialization. Typically, this will be the timezone specified in your database connection's ",(0,i.kt)("inlineCode",{parentName:"p"},"qt_timezone")," configuration option."),(0,i.kt)("h3",{id:"query-time-casting"},"Query Time Casting"),(0,i.kt)("p",null,"Sometimes you may need to apply casts while executing a query, such as when selecting a raw value from a table. For example, consider the following query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'using Models::Post;\nusing Models::User;\n\nauto users = User::select("users.*")\n             ->addSelect(\n                 Post::selectRaw("MAX(created_at)")\n                     ->whereColumnEq("user_id", "users.id")\n                     .toBase(),\n                 "last_posted_at"\n             ).get();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"last_posted_at")," attribute on the results of this query will be a simple string. It would be wonderful if we could apply a ",(0,i.kt)("inlineCode",{parentName:"p"},"CastType::QDateTime")," cast to this attribute when executing the query. Thankfully, we may accomplish this using the ",(0,i.kt)("inlineCode",{parentName:"p"},"withCasts")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"withCast")," methods:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'auto users = User::select("users.*")\n             ->addSelect(Post::selectRaw("MAX(created_at)")\n                             ->whereColumnEq("user_id", "users.id")\n                             .toBase(),\n                         "last_posted_at")\n             .withCast({"last_posted_at", CastType::QDateTime})\n             .get();\n')))}u.isMDXComponent=!0}}]);